ori $0,$0,0		#$0=0
ori $1,$0,1		#$1=1
ori $2,$0,2		#$2=2
ori $3,$0,3		#$3=3
ori $4,$0,4		#$4=4
ori $5,$0,5		#$5=5
sw $0,0x00000000     	#$0存入第一个内存
sw $1,0x00000020     	#$1存入第一个内存
sw $2,0x00000040     	#$2存入第一个内存
sw $3,0x00000080     	#$3存入第一个内存
sw $4,0x000000a0     	#$4存入第一个内存
sw $5,0x000000c0     	#$5存入第一个内存
lw $6,0x00000000     	#取出内存中的数：$6=0
lw $7,0x00000020     	#取出内存中的数：$7=1
lw $8,0x00000040     	#取出内存中的数：$8=2
lw $9,0x00000080     	#取出内存中的数：$9=3
lw $10,0x000000a0     	#取出内存中的数：$10=4
lw $11,0x000000c0     	#取出内存中的数：$11=5
lui $6,1			#把1加载到$6的高位
lui $7,2			#把1加载到$7的高位
	beq 	$5,$11,go1		#$5=$0则转移到go1
	addu 	$12,$1,$2		#$12=1+2=3,beq指令正确则不执行
go1:	addu	$12,$1,$3		#$12=1+3=4
	beq	$5,$1,go2		#$5!=$1,所以不应跳转
	subu 	$13,$10,$3		#$13=4-3=1
go2:	addu 	$14,$3,$9		#$14=3+3=6
	ori	$20,$0,6			#$20=6
	ori	$22,$0,3			#$22=3
	jal 	go3			#转移到go3
	addu 	$15,$3,$4		#$15=3+4=7
	j 	go4			#转移到go4
	ori 	$17,$0,2			#$17=2
go3:	addu 	$16,$3,$5		#$16=3+5=8
	jr 	$ra			#跳回到jal后的第一条指令
go4:	addu 	$17,$5,$11		#$17=5+5=10
go5:	subu 	$20,$20,$1		#$20=$20-1=5
	beq	$20,$3,go6		#$20=3,go6
	beq 	$22,$3,go7		#$22=3,then go7
go7:	beq 	$11,$20,go5		#$11==$20时则转移到go5,then,$20=4
	j 	go5			#跳转到go5，then $20=3
go8:	addu	$23,$1,$1		#$23=2
	jr	$ra			#跳回到jal后的第一条指令
go6:	jal 	go8			#跳转到go5，then $20=2
	addu	$21,$20,$1		#$21=2+1=3


